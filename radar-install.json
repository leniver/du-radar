{"slots":{"0":{"name":"radar","type":{"methods":[],"events":[]},"class":"RadarPVPUnit"},"1":{"name":"slot1","type":{"methods":[],"events":[]}},"2":{"name":"slot2","type":{"methods":[],"events":[]}},"3":{"name":"slot3","type":{"methods":[],"events":[]}},"4":{"name":"slot4","type":{"methods":[],"events":[]}},"5":{"name":"slot5","type":{"methods":[],"events":[]}},"6":{"name":"slot6","type":{"methods":[],"events":[]}},"7":{"name":"slot7","type":{"methods":[],"events":[]}},"8":{"name":"slot8","type":{"methods":[],"events":[]}},"9":{"name":"slot9","type":{"methods":[],"events":[]}},"10":{"name":"slot10","type":{"methods":[],"events":[]}},"11":{"name":"slot11","type":{"methods":[],"events":[]}},"12":{"name":"slot12","type":{"methods":[],"events":[]}},"13":{"name":"slot13","type":{"methods":[],"events":[]}},"14":{"name":"slot14","type":{"methods":[],"events":[]}},"15":{"name":"slot15","type":{"methods":[],"events":[]}},"16":{"name":"slot16","type":{"methods":[],"events":[]}},"17":{"name":"slot17","type":{"methods":[],"events":[]}},"18":{"name":"slot18","type":{"methods":[],"events":[]}},"19":{"name":"slot19","type":{"methods":[],"events":[]}},"20":{"name":"slot20","type":{"methods":[],"events":[]}},"-5":{"name":"library","type":{"methods":[],"events":[]}},"-4":{"name":"system","type":{"methods":[],"events":[]}},"-3":{"name":"player","type":{"methods":[],"events":[]}},"-2":{"name":"construct","type":{"methods":[],"events":[]}},"-1":{"name":"unit","type":{"methods":[],"events":[]}}},"handlers":[{"key":0,"filter":{"slotKey":-5,"signature":"onStart()","args":[{"variable":"*"}]},"code":"function library.addEventHandlers(a)if not a or a.onEvent and a.triggerEvent then return false end;if'table'~=type(a)then error('You can only add event handlers to table objects!')end;local b=0;local c={}a.onEvent=function(self,d,e,f)if'function'~=type(e)then error('Event handler must be a function!')end;f=f or self;if'table'~=type(f)then error('The value of self must be a table!')end;if not c[d]then c[d]={}end;b=b+1;c[d][b]={e,f}return b end;a.clearEvent=function(self,d,g)if c[d]and c[d][g]then c[d][g]=nil end end;a.triggerEvent=function(self,d,...)for h,e in pairs(c[d]or{})do e[1](e[2],...)end end;return true end\nlocal a=DULibrary or{}function a.getLinks(b,c)local d={}if not b then b={}end;local e=0;for f,g in pairs(unit)do if'table'==type(g)and'function'==type(g.getClass)then local h=true;for i,j in pairs(b)do if not('function'==type(g[i])and j==g[i]():sub(1,#j))then h=false end end;if h then e=e+1;if c then f=e end;d[f]=g end end end;return d end;function a.getLinksByClass(k,c)return a.getLinks({getClass=k},c)end;function a.getLinkByClass(k)return a.getLinksByClass(k,true)[1]end;function a.getCoreUnit()return a.getLinkByClass('CoreUnit')end;function a.getLinkByName(l)local m=a.getCoreUnit()if not m then error('getLinkByName requires a linked CoreUnit to work')end;local d=a.getLinks()for n,g in pairs(d)do if l==m.getElementNameById(g.getLocalId())then return g end end end\n"},{"key":1,"filter":{"slotKey":-5,"signature":"onStart()","args":[{"variable":"*"}]},"code":"package.preload['DURadar:radar-construct'] = (function (...) ---@class RadarConstruct\n---@field parent RadarHandler\n---@field id number\n---@field size string\n---@field name string\n---@field distance number\n---@field isIdentified boolean\n---@field isTargeted boolean\n---@field myThreatStateToTarget string\n---@field targetThreatState number\n---@field isReachable boolean\n---@field __lastRefresh number\nRadarConstruct = {}\nRadarConstruct.__index = RadarConstruct\n\nlocal min, random = math.min, math.random\nlocal upper = string.upper\n\n---@enum\nRadarConstructType = {\n    Universe = 1,\n    Planet = 2,\n    Asteroid = 3,\n    Static = 4,\n    Dynamic = 5,\n    Space = 6,\n    Alien = 7,\n}\n\n---@enum\nRadarConstructSize = {\n    XS = \"XS\",\n    S = \"S\",\n    M = \"M\",\n    L = \"L\",\n    XL = \"XL\",\n}\n\n\n---@param parent RadarHandler\n---@param id number\n---@param filter function\n---@return RadarConstruct\nfunction RadarConstruct.new(parent, id, filter)\n    local self = setmetatable({}, RadarConstruct)\n\n    self.parent = parent\n\n    self.id = id\n    self.size = upper(self.parent.radar.getConstructCoreSize(self.id))\n    self.type = self.parent.radar.getConstructKind(self.id)\n    self.name = self.parent.radar.getConstructName(self.id)\n    if type(filter) == \"function\" and not filter(self) then\n        self.isReachable = false\n        return self\n    end\n    self.distance = 0\n    self.isIdentified = false\n    self.myThreatStateToTarget = \"\"\n    self.targetThreatState = 0\n    self.isReachable = false\n    self.isTargeted = false\n    self.__lastRefresh = 0\n    self.__threatRefreshLimit = random(3, 8)\n    self:refresh()\n\n    return self\nend\n\n---@param a RadarConstruct\n---@param b RadarConstruct\n---@return boolean\nfunction RadarConstruct.__eq(a, b)\n    return a.distance == b.distance\nend\n\n---@param a RadarConstruct\n---@param b RadarConstruct\n---@return boolean\nfunction RadarConstruct.__lt(a, b)\n    return (a.distance < b.distance) or (a.distance == b.distance and a.id < b.id)\nend\n\n---@param a RadarConstruct\n---@param b RadarConstruct\n---@return boolean\nfunction RadarConstruct.__le(a, b)\n    return (a.distance > b.distance) and (a.id > b.id)\nend\n\n---@param status boolean\nfunction RadarConstruct:setIdentified(status)\n    self.isIdentified = status\nend\n\n---@param status boolean\nfunction RadarConstruct:setTargeted(status)\n    self.isTargeted = status\nend\n\n---@param time? number\nfunction RadarConstruct:refresh(time)\n    time = (time or 0)\n    local timeDiff = time - self.__lastRefresh\n    if time == 0 or (timeDiff > 10) or (timeDiff > 2 and self.distance < 500) then\n        self.distance = self.parent.radar.getConstructDistance(self.id)\n        self.isReachable = self.distance > 0\n        if not self.isReachable then\n            self.name = self.parent.radar.getConstructName(self.id)\n            self.isReachable = self.name ~= \"unreachable\"\n        elseif (not self.parent.isAtmospheric) and (self.distance < self.parent.radarRange) then\n            self.__threatRefreshLimit = self.__threatRefreshLimit - 1\n            if self.__threatRefreshLimit == 0 then\n                self.myThreatStateToTarget = self.parent.radar.getThreatRateFrom(self.id)\n                self.targetThreatState = self.parent.radar.getThreatRateTo(self.id)\n                self.__threatRefreshLimit = random(3, 8)\n            end\n        end\n        self.__lastRefresh = time\n    end\nend\n\n---@param maxIdentifyRange number\n---@return string\nfunction RadarConstruct:getData(maxIdentifyRange)\n    return [[{]] ..\n        [[\"constructId\":]] .. self.id ..\n        [[,\"distance\":]] .. self.distance ..\n        [[,\"isIdentifyRange\":]] .. tostring(maxIdentifyRange >= self.distance) ..\n        [[,\"info\":{}]] ..\n        [[,\"isIdentified\":]] .. tostring(self.isIdentified) ..\n        [[,\"myThreatStateToTarget\":0]] .. ---self.myThreatStateToTarget ..\n        [[,\"name\":\"]] .. self.name .. [[\"]] ..\n        [[,\"size\":\"]] .. self.size .. [[\"]] ..\n        [[,\"targetThreatState\":0]] .. ---self.targetThreatState ..\n        [[}]]\nend\n; end)"},{"key":2,"filter":{"slotKey":-5,"signature":"onStart()","args":[{"variable":"*"}]},"code":"package.preload['DURadar:radar-handler'] = (function (...) ---@class RadarHandler\n---@field unit ControlUnit\n---@field system System\n---@field radar Radar\n---@field isAtmospheric boolean\n---@field radarRange number\n---@field globalFilter? function\n---@field constructs RadarConstruct[]\n---@field __updating boolean\n---@field __updateList number[]\n---@field __updateQueue number[]\n---@field __refreshing boolean\n---@field __refreshList number[]\n---@field __refreshCount number\n---@field __widgetTimers number\n---@field __widgetData string\n---@field __lastIdentifiedConstructs boolean[]\n---@field __lastTargetedConstruct number\nRadarHandler = {}\nRadarHandler.__index = RadarHandler\n\nlocal sort, concat = table.sort, table.concat\nlocal len, match = string.len, string.match\nlocal min, random = math.min, math.random\nlocal cresume, ccreate = coroutine.resume, coroutine.create\n\n---@param unit ControlUnit\n---@param system System\n---@param radar Radar\n---@param filter function?\nfunction RadarHandler.new(unit, system, radar, filter)\n    local self = setmetatable({}, RadarHandler)\n\n    self.unit = unit\n    self.system = system\n    self.radar = radar\n    self.isAtmospheric = match(self.radar.getClass(), \"Atmospheric\") ~= nil\n    self.radarRange = self.radar.getRange()\n\n    self.globalFilter = filter\n    self.constructs = {}\n    self.count = 0\n\n    self.__updating = false\n    self.__updateList = self.radar.getConstructIds()\n    self.__updateQueue = {}\n    self.__refreshing = false\n    self.__refreshList = {}\n    self.__refreshCount = 0\n\n    self.__widgetTimers = 0\n    self.__widgetData = self.radar.getWidgetData():gsub(\"\\\"constructsList\\\":%[?{?[^%]]*%]?}?,\", \"CONSTRUCTLIST\")\n\n    self.__lastIdentifiedConstructs = {}\n    self.__lastTargetedConstruct = 0\n\n    self:initEvent()\n\n    return self\nend\n\n---@param count? number\n---@param filter? function\n---@return RadarConstruct[]\n---@return number\nfunction RadarHandler:getClosestConstructs(count, filter)\n    local constructs = {}\n    local isFunction = type(filter) == \"function\"\n    for _, construct in pairs(self.constructs) do\n        if not isFunction or filter(construct) then\n            constructs[#constructs + 1] = construct\n        end\n    end\n    sort(constructs, function(a, b) return a.distance < b.distance end)\n\n    local result = {}\n    local n = min(#constructs, (count or 2000000))\n    for i = 1, n, 1 do\n        result[#result + 1] = constructs[i]\n    end\n    return result, n\nend\n\nfunction RadarHandler:onUpdate()\n    if not self.__updating then\n        self.__updating = true\n        cresume(ccreate(function()\n            local q = self.__updateQueue\n            self.__updateQueue = {}\n            for i in ipairs(q) do\n                self.__updateList[#self.__updateList + 1] = q[i]\n            end\n            local n = min(#self.__updateList, 50)\n            for i = 1, n, 1 do\n                local id = self.__updateList[#self.__updateList]\n                self.__updateList[#self.__updateList] = nil\n                if self.constructs[id] ~= nil then\n                    self.constructs[id]:refresh()\n                    if not self.constructs[id].isReachable then\n                        self.constructs[id] = nil\n                        self.count = self.count - 1\n                    end\n                else\n                    local construct = RadarConstruct.new(self, id, self.globalFilter)\n                    if construct.isReachable then\n                        self.constructs[id] = construct\n                        self.count = self.count + 1\n                    end\n                end\n            end\n            self.__updating = false\n        end))\n    end\nend\n\nfunction RadarHandler:onRefresh()\n    if not self.__refreshing then\n        self.__refreshing = true\n        cresume(ccreate(function()\n            self.__refreshCount = self.__refreshCount + 1\n            if #self.__refreshList == 0 then\n                for id in pairs(self.constructs) do\n                    self.__refreshList[#self.__refreshList + 1] = id\n                end\n            end\n            local n = min(#self.__refreshList, 50)\n            for i = 1, n, 1 do\n                local id = self.__refreshList[#self.__refreshList]\n                self.__refreshList[#self.__refreshList] = nil\n                if self.constructs[id] ~= nil then\n                    self.constructs[id]:refresh(self.__refreshCount)\n                    if not self.constructs[id].isReachable then\n                        self.constructs[id] = nil\n                        self.count = self.count - 1\n                    end\n                end\n            end\n            if self.__refreshCount % 10 == 0 then\n                local identifiedConstructs = self.radar.getIdentifiedConstructIds()\n                local newIdentifiedConstructs = {}\n                for i = 1, #identifiedConstructs do\n                    if self.constructs[identifiedConstructs[i]] ~= nil then\n                        self.constructs[identifiedConstructs[i]]:setIdentified(true)\n                    end\n                    self.__lastIdentifiedConstructs[identifiedConstructs[i]] = nil\n                    newIdentifiedConstructs[identifiedConstructs[i]] = true\n                end\n                for k in pairs(self.__lastIdentifiedConstructs) do\n                    if self.constructs[k] ~= nil then\n                        self.constructs[k]:setIdentified(false)\n                    end\n                end\n                self.__lastIdentifiedConstructs = newIdentifiedConstructs\n\n                local targetId = self.radar.getTargetId()\n                if self.__lastTargetedConstruct ~= targetId then\n                    if self.constructs[targetId] ~= nil then\n                        self.constructs[targetId]:setTargeted(true)\n                    end\n                    if self.constructs[self.__lastTargetedConstruct] ~= nil then\n                        self.constructs[self.__lastTargetedConstruct]:setTargeted(false)\n                    end\n                    self.__lastTargetedConstruct = targetId\n                end\n\n            end\n\n            --- If in a crowded area, can lag and dont give the construct list at initialization\n            if self.count == 0 then\n                self.__updateList = self.radar.getConstructIds()\n            end\n            self.__refreshing = false\n        end))\n    end\nend\n\nfunction RadarHandler:initEvent()\n    ---@diagnostic disable-next-line: undefined-field\n    self.system:onEvent(\"onUpdate\", function()\n        self:onUpdate()\n        self:onRefresh()\n    end, self)\n    ---@diagnostic disable-next-line: undefined-field\n    self.radar:onEvent(\"onEnter\", function(_, id)\n        self.__updateQueue[#self.__updateQueue + 1] = id\n    end, self)\nend\n\n---@param count? number\n---@param filter? function\n---@return string\nfunction RadarHandler:getWidgetData(count, filter)\n    local constructs = {}\n    for _, construct in pairs(self:getClosestConstructs(count, filter)) do\n        constructs[#constructs + 1] = construct:getData(self.radarRange)\n    end\n    local widgetData = self.__widgetData:gsub(\"CONSTRUCTLIST\", \"\\\"constructsList\\\":[\" .. concat(constructs, \",\") .. \"],\")\n    return widgetData\nend\n\n---@param name string\n---@param count? number\n---@param filter? function\n---@return string\n---@return string\n---@return string\nfunction RadarHandler:createWidget(name, count, filter)\n    local panelId = self.system.createWidgetPanel(name)\n    local widgetId = \"\"\n    local dataId = \"\"\n    if len(panelId) > 0 then\n        widgetId = self.system.createWidget(panelId, \"radar\")\n        if len(widgetId) > 0 then\n            dataId = self.system.createData(\"{}\")\n            if len(dataId) > 0 then\n                self.system.addDataToWidget(dataId, widgetId)\n\n                local timer = \"radarWidget_\" .. self.__widgetTimers\n                ---@diagnostic disable-next-line: undefined-field\n                self.unit:onEvent(\"onTimer\", function(_, timerId)\n                    if timer == timerId then\n                        self.system.updateData(dataId, self:getWidgetData(count, filter))\n                    end\n                end, self)\n                self.unit.setTimer(timer, 0.3 + (random() * 2 / 10))\n\n                self.__widgetTimers = self.__widgetTimers + 1\n            end\n        end\n    end\n\n    return panelId, widgetId, dataId\nend\n; end)"},{"key":3,"filter":{"slotKey":-5,"signature":"onStart()","args":[{"variable":"*"}]},"code":"package.preload['DURadar:wrapper'] = (function (...) ---@class Wrapper\n---@field unit ControlUnit\n---@field system System\n---@field stopped boolean\n---@field stopOnError boolean\n---@field rethrowErrorAlways boolean\n---@field rethrowErrorIfStopped boolean\n---@field printSameErrorOnlyOnce boolean\n---@field printError boolean\n---@field error function\n---@field traceback function\n---@field __memoryUsage number\n---@field __memoryUsed number\n---@field __memoryMax number\n---@field __memoryIteration number\nWrapper = {}\nWrapper.__index = Wrapper\n\nlocal max, ceil = math.max, math.ceil\n\nsetmetatable(Wrapper, {\n  __call = function (cls, ...)\n    return cls.new(...)\n  end,\n})\n\n---@type {[string] : boolean}\nlocal logs = {}\n\n---@param unit ControlUnit\n---@param system System\n---@return Wrapper\nfunction Wrapper.new(unit, system)\n    local self = setmetatable({}, Wrapper)\n    \n    self.unit = unit\n    self.system = system\n    self.stopped = false\n    self.stopOnError = false\n    self.rethrowErrorAlways = false\n    self.rethrowErrorIfStopped = true\n    self.printSameErrorOnlyOnce = true\n    self.printError = true\n    self.error = function(a)\n        if self.stopped then\n            return\n        end\n        a = tostring(a):gsub('\"%-%- |STDERROR%-EVENTHANDLER[^\"]*\"', 'chunk')\n        local b = self.unit or self or {}\n        if self.printError and self.system and self.system.print then\n            if not self.printSameErrorOnlyOnce or logs[a] == nil then\n                logs[a] = true\n                self.system.print(a)\n            end\n        end\n        if self.stopOnError then\n            self.stopped = true\n        end\n        if self.stopped and b and b.exit then\n            b.exit()\n        end\n        if self.rethrowErrorAlways or (self.stopped and self.rethrowErrorIfStopped) then\n            error(a)\n        end\n    end\n    self.traceback = traceback or (debug and debug.traceback) or function(a, b) return b or a end\n\n    self.__memoryUsage = 0\n    self.__memoryUsed = 0\n    self.__memoryMax = 0\n    self.__memoryIteration = 0\n\n    return self\nend\n\n---@return number\nfunction Wrapper:getMemoryAverage()\n    return ceil(self.__memoryUsed / self.__memoryIteration * 100) / 100\nend\n\n---@return number\nfunction Wrapper:getMemoryUsage()\n    return ceil(self.__memoryUsage * 100) / 100\nend\n\n---@return number\nfunction Wrapper:getMemoryMax()\n    return ceil(self.__memoryMax * 100) / 100\nend\n\n---@param callback any\nfunction Wrapper:execute(callback)\n    if not self.stopped then\n        local a, b = xpcall(callback, self.traceback, self.unit)\n        if not a then\n            self.error(b)\n        end\n    end\n\n    self.__memoryUsage = collectgarbage(\"count\")\n    self.__memoryUsed = self.__memoryUsed + self.__memoryUsage\n    self.__memoryMax = max(self.__memoryMax, self.__memoryUsage)\n    self.__memoryIteration = self.__memoryIteration + 1\nend; end)"},{"key":4,"filter":{"slotKey":-4,"signature":"onActionStart(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent(\"onActionStart\",action)"},{"key":5,"filter":{"slotKey":-4,"signature":"onActionLoop(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent(\"onActionLoop\",action)"},{"key":6,"filter":{"slotKey":-4,"signature":"onActionStop(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent(\"onActionStop\",action)"},{"key":7,"filter":{"slotKey":-4,"signature":"onUpdate()","args":[{"variable":"*"}]},"code":"system:triggerEvent(\"onUpdate\")"},{"key":8,"filter":{"slotKey":-4,"signature":"onFlush()","args":[{"variable":"*"}]},"code":"system:triggerEvent(\"onFlush\")"},{"key":9,"filter":{"slotKey":-4,"signature":"onInputText(text)","args":[{"variable":"*"}]},"code":"system:triggerEvent(\"onInputText\",text)"},{"key":10,"filter":{"slotKey":-4,"signature":"onCameraChanged(mode)","args":[{"variable":"*"}]},"code":"system:triggerEvent(\"onCameraChanged\",mode)"},{"key":11,"filter":{"slotKey":-3,"signature":"onParentChanged(oldId,newId)","args":[{"variable":"*"},{"variable":"*"}]},"code":"player:triggerEvent(\"onParentChanged\",oldId,newId)"},{"key":12,"filter":{"slotKey":-2,"signature":"onDocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent(\"onDocked\",id)"},{"key":13,"filter":{"slotKey":-2,"signature":"onUndocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent(\"onUndocked\",id)"},{"key":14,"filter":{"slotKey":-2,"signature":"onPlayerBoarded(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent(\"onPlayerBoarded\",id)"},{"key":15,"filter":{"slotKey":-2,"signature":"onVRStationEntered(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent(\"onVRStationEntered\",id)"},{"key":16,"filter":{"slotKey":-2,"signature":"onConstructDocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent(\"onConstructDocked\",id)"},{"key":17,"filter":{"slotKey":-2,"signature":"onPvPTimer(active)","args":[{"variable":"*"}]},"code":"construct:triggerEvent(\"onPvPTimer\",active)"},{"key":18,"filter":{"slotKey":-1,"signature":"onStart()","args":[{"variable":"*"}]},"code":"unit:triggerEvent(\"onStart\")"},{"key":19,"filter":{"slotKey":-1,"signature":"onStop()","args":[{"variable":"*"}]},"code":"unit:triggerEvent(\"onStop\")"},{"key":20,"filter":{"slotKey":-1,"signature":"onTimer(timerId)","args":[{"variable":"*"}]},"code":"unit:triggerEvent(\"onTimer\",timerId)"},{"key":21,"filter":{"slotKey":0,"signature":"onEnter(id)","args":[{"variable":"*"}]},"code":"radar:triggerEvent(\"onEnter\",id)"},{"key":22,"filter":{"slotKey":0,"signature":"onLeave(id)","args":[{"variable":"*"}]},"code":"radar:triggerEvent(\"onLeave\",id)"},{"key":23,"filter":{"slotKey":0,"signature":"onIdentified(id)","args":[{"variable":"*"}]},"code":"radar:triggerEvent(\"onIdentified\",id)"},{"key":24,"filter":{"slotKey":-5,"signature":"onStart()","args":[{"variable":"*"}]},"code":"-- Setup improved event handlers\nif not __EVENTS then\nlibrary.addEventHandlers(library)\nlibrary.addEventHandlers(system)\nlibrary.addEventHandlers(player)\nlibrary.addEventHandlers(construct)\nlibrary.addEventHandlers(unit)\nlibrary.addEventHandlers(radar)\n__EVENTS=true\nend"},{"key":25,"filter":{"slotKey":-1,"signature":"onStart()","args":[{"variable":"*"}]},"code":"require('DURadar:radar-construct')\nrequire('DURadar:radar-handler')\nrequire('DURadar:wrapper')\n--r equire('autoconf/custom/du-radar/radar-construct')\n--r equire('autoconf/custom/du-radar/radar-handler')\n--r equire('autoconf/custom/du-radar/wrapper')\n\nlocal max = math.max\n\nlocal wrapper = Wrapper(unit, system)\nwrapper:execute(function()\n  do\n    local newPause = 50\n    local oldPause = collectgarbage(\"setpause\", newPause)\n    if oldPause < newPause then\n      collectgarbage(\"setpause\", oldPause)\n    end\n  end\n\n  local r = RadarHandler.new(unit, system, radar)\n  local ceil = math.ceil\n  system.showScreen(true)\n\n  r:createWidget(\"Radar XS\", 20,\n    function(c) return c.size == RadarConstructSize.XS and c.type == RadarConstructType.Dynamic end)\n  r:createWidget(\"Radar S\", 20,\n    function(c) return c.size == RadarConstructSize.S and c.type == RadarConstructType.Dynamic end)\n  r:createWidget(\"Radar M\", 20,\n    function(c) return c.size == RadarConstructSize.M and c.type == RadarConstructType.Dynamic end)\n  r:createWidget(\"Radar L\", 20,\n    function(c) return c.size == RadarConstructSize.L and c.type == RadarConstructType.Dynamic end)\n\n  ---@diagnostic disable-next-line: undefined-field\n  system:onEvent(\"onUpdate\", function()\n    wrapper:execute(function()\n      local constructs, n = r:getClosestConstructs(45)\n      local content = \"\"\n      for i = 1, n, 1 do\n        content = content ..\n            \"[\" .. constructs[i].id .. \"] \" ..\n            constructs[i].name ..\n            \" (\" .. ceil(constructs[i].distance) .. \")<br/>\"\n      end\n\n      content = content .. \"<br/><br/>Ship count: \" .. r.count\n      content = content .. \"<br/>Memory usage: \" .. wrapper:getMemoryUsage()\n      content = content .. \"<br/>Memory average: \" .. wrapper:getMemoryAverage()\n      content = content .. \"<br/>Memory max: \" .. wrapper:getMemoryMax()\n\n      system.setScreen(content)\n    end)\n  end)\nend)\n"}],"methods":[],"events":[]}